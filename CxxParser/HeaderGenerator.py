from typing import List
import Analyser

def to_named_params(types, names):
    formatted_params = []
                
    # Don't write the this parameter
    offset = 0
    
    if len(names) == 0:
        return ", ".join(types)
    
    if names[0] == "this":
        offset = 1
        
        if len(names) == 1:
            return ""    
    
                
    for (index, param) in enumerate(types):
        formatted = param
                    
        if names[index + offset] != "":
            formatted += f" {names[index + offset]}"
                    
        formatted_params.append(formatted) 
        
    return ", ".join(formatted_params)

class HeaderGenerator:
    class_name: str
    vtable_entries: List[dict]
    
    def __init__(self, class_name, vtable_entries) -> None:
        self.class_name = class_name
        self.vtable_entries = vtable_entries
        
    def to_header(self) -> str:
        h = f"// Automatically generated by FrederoxDev/Reverse-Tools/CxxParser/HeaderGenerator.py\n\n"
        h += "%FORWARD_DECLS%\n\n"
        
        classes = set()
        structs = set()
        enums = set()
        
        h += f"class {self.class_name} {'{'}\n"
        h += "public:\n"
        
        for entry in self.vtable_entries:
            was_success = entry["success"]
            symbol = entry["symbol"]
            
            if not was_success:
                h += f"\t// Failed to match '{symbol}'\n"
                continue
            
            did_match_params = entry["found_params"]
            param_names = entry["matched_params"]
            name_matches = entry["named_matched_params"]
            win_function = entry["win_function"]
            
            Analyser.get_all_types_used(win_function, classes, structs, enums)
            function_params = Analyser.simplify_parameters(Analyser.parameter_types(win_function))
            function_name = Analyser.function_name(win_function)
            function_return = Analyser.simplify_parameters([Analyser.return_type(win_function)])[0]
            
            formatted_params = ', '.join(function_params)
            
            # Don't bother to do params for functions with no params
            if function_params == ["void"]:
                formatted_params = ""
            
            elif did_match_params:
                formatted_params = to_named_params(function_params, param_names)
                       
            if not did_match_params:
                known_options_str = ", known options:"
                if len(name_matches) == 0:
                    known_options_str = ""
                    
                h += f"\n\t// Unknown Parameters{known_options_str}\n"
                
                for name_match in name_matches:
                    h += f"\t// ({to_named_params(name_match[0], name_match[1])})\n"
                    
                h += f"\tvirtual {function_return} {function_name}({formatted_params});\n\n"
                
            else:
                h += f"\tvirtual {function_return} {function_name}({formatted_params});\n"
            
        h += "};"
        
        forward_decls = ""
        for class_name in classes:
            forward_decls += f"class {class_name};\n"
            
        for struct_name in structs:
            forward_decls += f"struct {struct_name};\n"
            
        for enum_name in enums:
            forward_decls += f"enum {enum_name};\n"

        h = h.replace("%FORWARD_DECLS%", forward_decls)
        
        return h